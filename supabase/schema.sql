-- =========================
-- INDYCAR Fantasy: Step 1 Schema
-- =========================

create extension if not exists pgcrypto;

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = timezone('utc', now());
  return new;
end;
$$;

-- Profiles (extends auth.users)
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  full_name text,
  team_name text not null unique,
  phone_number text,
  phone_carrier text,
  role text not null default 'participant' check (role in ('admin', 'participant')),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

-- Drivers
create table if not exists public.drivers (
  id bigint generated by default as identity primary key,
  driver_name text not null unique,
  image_url text,
  championship_points integer not null default 0 check (championship_points >= 0),
  current_standing integer not null check (current_standing > 0),
  group_number smallint not null check (group_number between 1 and 6),
  is_active boolean not null default true,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

-- Races
create table if not exists public.races (
  id bigint generated by default as identity primary key,
  race_name text not null,
  title_image_url text,
  qualifying_start_at timestamptz not null,
  race_date timestamptz not null,
  payout numeric(10,2) not null default 0,
  official_winning_average_speed numeric(8,3) check (official_winning_average_speed >= 0),
  winner_profile_id uuid references public.profiles(id) on delete set null,
  winner_source text not null default 'auto' check (winner_source in ('auto', 'manual')),
  winner_is_manual_override boolean not null default false,
  winner_auto_eligible_at timestamptz,
  winner_set_at timestamptz,
  is_archived boolean not null default false,
  archived_at timestamptz,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  unique (race_name, race_date),
  check (qualifying_start_at <= race_date)
);

-- Picks (exactly 1 driver per group + tiebreaker speed)
create table if not exists public.picks (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles(id) on delete cascade,
  race_id bigint not null references public.races(id) on delete cascade,
  average_speed numeric(7,3) not null check (average_speed > 0),
  driver_group1_id bigint not null references public.drivers(id),
  driver_group2_id bigint not null references public.drivers(id),
  driver_group3_id bigint not null references public.drivers(id),
  driver_group4_id bigint not null references public.drivers(id),
  driver_group5_id bigint not null references public.drivers(id),
  driver_group6_id bigint not null references public.drivers(id),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  unique (user_id, race_id)
);

-- Results (official points by race/driver)
create table if not exists public.results (
  id bigint generated by default as identity primary key,
  race_id bigint not null references public.races(id) on delete cascade,
  driver_id bigint not null references public.drivers(id) on delete cascade,
  points integer not null check (points >= 0),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  unique (race_id, driver_id)
);

-- Feedback submissions
create table if not exists public.feedback_items (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles(id) on delete cascade,
  feedback_type text not null check (feedback_type in ('bug', 'improvement')),
  category text not null,
  context_page text,
  details text not null,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

-- Pick reminder notifications (cron dedupe/log)
create table if not exists public.pick_reminders (
  id bigint generated by default as identity primary key,
  race_id bigint not null references public.races(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  reminder_type text not null check (reminder_type in ('4d', '2d', '2h')),
  channel text not null check (channel in ('email', 'sms')),
  recipient text not null,
  delivery_status text not null default 'pending' check (delivery_status in ('pending', 'sent')),
  delivery_id text,
  sent_at timestamptz not null default timezone('utc', now()),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  unique (race_id, user_id, reminder_type, channel)
);

-- Indexes
create index if not exists idx_drivers_group on public.drivers(group_number, current_standing);
create index if not exists idx_drivers_points on public.drivers(championship_points desc, current_standing asc);
create index if not exists idx_races_date on public.races(race_date);
create index if not exists idx_races_qualifying_start on public.races(qualifying_start_at);
create index if not exists idx_races_winner_auto_eligible on public.races(winner_auto_eligible_at);
create index if not exists idx_races_is_archived on public.races(is_archived, race_date);
create index if not exists idx_picks_race on public.picks(race_id);
create index if not exists idx_picks_user on public.picks(user_id);
create index if not exists idx_results_race on public.results(race_id);
create index if not exists idx_feedback_items_created_at on public.feedback_items(created_at desc);
create index if not exists idx_feedback_items_user on public.feedback_items(user_id);
create index if not exists idx_pick_reminders_race on public.pick_reminders(race_id, reminder_type, channel);
create index if not exists idx_pick_reminders_user on public.pick_reminders(user_id, created_at desc);

-- updated_at triggers
drop trigger if exists trg_profiles_updated_at on public.profiles;
create trigger trg_profiles_updated_at
before update on public.profiles
for each row execute function public.set_updated_at();

drop trigger if exists trg_drivers_updated_at on public.drivers;
create trigger trg_drivers_updated_at
before update on public.drivers
for each row execute function public.set_updated_at();

drop trigger if exists trg_races_updated_at on public.races;
create trigger trg_races_updated_at
before update on public.races
for each row execute function public.set_updated_at();

drop trigger if exists trg_picks_updated_at on public.picks;
create trigger trg_picks_updated_at
before update on public.picks
for each row execute function public.set_updated_at();

drop trigger if exists trg_results_updated_at on public.results;
create trigger trg_results_updated_at
before update on public.results
for each row execute function public.set_updated_at();

drop trigger if exists trg_feedback_items_updated_at on public.feedback_items;
create trigger trg_feedback_items_updated_at
before update on public.feedback_items
for each row execute function public.set_updated_at();

drop trigger if exists trg_pick_reminders_updated_at on public.pick_reminders;
create trigger trg_pick_reminders_updated_at
before update on public.pick_reminders
for each row execute function public.set_updated_at();

-- Enforce pick lock at the database layer
create or replace function public.enforce_pick_deadline()
returns trigger
language plpgsql
as $$
declare
  race_qualifying_start_at timestamptz;
  race_is_archived boolean;
begin
  select r.qualifying_start_at, r.is_archived
    into race_qualifying_start_at, race_is_archived
  from public.races r
  where r.id = new.race_id;

  if race_qualifying_start_at is null then
    raise exception 'Race not found for pick submission';
  end if;

  if race_is_archived then
    raise exception 'Picks are disabled for archived races.';
  end if;

  if race_qualifying_start_at <= now() then
    raise exception 'Picks are locked because qualifying has already started.';
  end if;

  return new;
end;
$$;

drop trigger if exists trg_enforce_pick_deadline on public.picks;
create trigger trg_enforce_pick_deadline
before insert or update on public.picks
for each row execute function public.enforce_pick_deadline();

-- Validate pick groups + uniqueness of selected drivers
create or replace function public.validate_pick_groups()
returns trigger
language plpgsql
as $$
declare
  selected_driver_ids bigint[];
  distinct_count integer;
begin
  selected_driver_ids := array[
    new.driver_group1_id,
    new.driver_group2_id,
    new.driver_group3_id,
    new.driver_group4_id,
    new.driver_group5_id,
    new.driver_group6_id
  ];

  if not exists (select 1 from public.drivers where id = new.driver_group1_id and group_number = 1 and is_active) then
    raise exception 'Invalid Group 1 driver';
  end if;
  if not exists (select 1 from public.drivers where id = new.driver_group2_id and group_number = 2 and is_active) then
    raise exception 'Invalid Group 2 driver';
  end if;
  if not exists (select 1 from public.drivers where id = new.driver_group3_id and group_number = 3 and is_active) then
    raise exception 'Invalid Group 3 driver';
  end if;
  if not exists (select 1 from public.drivers where id = new.driver_group4_id and group_number = 4 and is_active) then
    raise exception 'Invalid Group 4 driver';
  end if;
  if not exists (select 1 from public.drivers where id = new.driver_group5_id and group_number = 5 and is_active) then
    raise exception 'Invalid Group 5 driver';
  end if;
  if not exists (select 1 from public.drivers where id = new.driver_group6_id and group_number = 6 and is_active) then
    raise exception 'Invalid Group 6 driver';
  end if;

  select count(distinct d) into distinct_count
  from unnest(selected_driver_ids) as t(d);

  if distinct_count <> 6 then
    raise exception 'Each pick must contain 6 distinct drivers';
  end if;

  return new;
end;
$$;

drop trigger if exists trg_validate_pick_groups on public.picks;
create trigger trg_validate_pick_groups
before insert or update on public.picks
for each row execute function public.validate_pick_groups();

-- Auto-create profile when auth user is created
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles (id, full_name, team_name)
  values (
    new.id,
    coalesce(new.raw_user_meta_data->>'full_name', ''),
    coalesce(nullif(new.raw_user_meta_data->>'team_name', ''), 'Team-' || new.id::text)
  );
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute function public.handle_new_user();

-- Admin helper for policies
create or replace function public.is_admin(uid uuid)
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select exists (
    select 1
    from public.profiles p
    where p.id = uid
      and p.role = 'admin'
  );
$$;

grant execute on function public.is_admin(uuid) to authenticated;

-- RLS
alter table public.profiles enable row level security;
alter table public.drivers enable row level security;
alter table public.races enable row level security;
alter table public.picks enable row level security;
alter table public.results enable row level security;
alter table public.feedback_items enable row level security;
alter table public.pick_reminders enable row level security;

-- profiles policies
drop policy if exists profiles_select_self_or_admin on public.profiles;
create policy profiles_select_self_or_admin
on public.profiles
for select
to authenticated
using (id = auth.uid() or public.is_admin(auth.uid()));

drop policy if exists profiles_insert_self on public.profiles;
create policy profiles_insert_self
on public.profiles
for insert
to authenticated
with check (id = auth.uid());

drop policy if exists profiles_update_self_or_admin on public.profiles;
create policy profiles_update_self_or_admin
on public.profiles
for update
to authenticated
using (id = auth.uid() or public.is_admin(auth.uid()))
with check (id = auth.uid() or public.is_admin(auth.uid()));

-- drivers policies
drop policy if exists drivers_read_all on public.drivers;
create policy drivers_read_all
on public.drivers
for select
to authenticated
using (true);

drop policy if exists drivers_admin_write on public.drivers;
create policy drivers_admin_write
on public.drivers
for all
to authenticated
using (public.is_admin(auth.uid()))
with check (public.is_admin(auth.uid()));

-- races policies
drop policy if exists races_read_all on public.races;
create policy races_read_all
on public.races
for select
to authenticated
using (true);

drop policy if exists races_admin_write on public.races;
create policy races_admin_write
on public.races
for all
to authenticated
using (public.is_admin(auth.uid()))
with check (public.is_admin(auth.uid()));

-- picks policies
drop policy if exists picks_select_own_or_admin on public.picks;
create policy picks_select_own_or_admin
on public.picks
for select
to authenticated
using (user_id = auth.uid() or public.is_admin(auth.uid()));

drop policy if exists picks_insert_own on public.picks;
create policy picks_insert_own
on public.picks
for insert
to authenticated
with check (user_id = auth.uid());

drop policy if exists picks_update_own_or_admin on public.picks;
create policy picks_update_own_or_admin
on public.picks
for update
to authenticated
using (user_id = auth.uid() or public.is_admin(auth.uid()))
with check (user_id = auth.uid() or public.is_admin(auth.uid()));

drop policy if exists picks_delete_own_or_admin on public.picks;
create policy picks_delete_own_or_admin
on public.picks
for delete
to authenticated
using (user_id = auth.uid() or public.is_admin(auth.uid()));

-- results policies
drop policy if exists results_read_all on public.results;
create policy results_read_all
on public.results
for select
to authenticated
using (true);

drop policy if exists results_admin_write on public.results;
create policy results_admin_write
on public.results
for all
to authenticated
using (public.is_admin(auth.uid()))
with check (public.is_admin(auth.uid()));

-- feedback policies
drop policy if exists feedback_items_select_own_or_admin on public.feedback_items;
create policy feedback_items_select_own_or_admin
on public.feedback_items
for select
to authenticated
using (user_id = auth.uid() or public.is_admin(auth.uid()));

drop policy if exists feedback_items_insert_own on public.feedback_items;
create policy feedback_items_insert_own
on public.feedback_items
for insert
to authenticated
with check (user_id = auth.uid());

drop policy if exists feedback_items_update_admin on public.feedback_items;
create policy feedback_items_update_admin
on public.feedback_items
for update
to authenticated
using (public.is_admin(auth.uid()))
with check (public.is_admin(auth.uid()));

drop policy if exists feedback_items_delete_admin on public.feedback_items;
create policy feedback_items_delete_admin
on public.feedback_items
for delete
to authenticated
using (public.is_admin(auth.uid()));

-- pick reminder policies
drop policy if exists pick_reminders_admin_read on public.pick_reminders;
create policy pick_reminders_admin_read
on public.pick_reminders
for select
to authenticated
using (public.is_admin(auth.uid()));
